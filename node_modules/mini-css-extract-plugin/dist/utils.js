"use strict";

const NativeModule = require("module");

const path = require("path");
/** @typedef {import("webpack").Compilation} Compilation */

/** @typedef {import("webpack").Module} Module */

/** @typedef {import("webpack").LoaderContext<any>} LoaderContext */

/**
 * @returns {boolean}
 */


function trueFn() {
  return true;
}
/**
 * @param {Compilation} compilation
 * @param {string | number} id
 * @returns {null | Module}
 */


function findModuleById(compilation, id) {
  const {
    modules,
    chunkGraph
  } = compilation;

  for (const module of modules) {
    const moduleId = typeof chunkGraph !== "undefined" ? chunkGraph.getModuleId(module) : module.id;

    if (moduleId === id) {
      return module;
    }
  }

  return null;
}
/**
 * @param {LoaderContext} loaderContext
 * @param {string | Buffer} code
 * @param {string} filename
 * @returns {object}
 */


function evalModuleCode(loaderContext, code, filename) {
  // @ts-ignore
  const module = new NativeModule(filename, loaderContext); // @ts-ignore

  module.paths = NativeModule._nodeModulePaths(loaderContext.context); // eslint-disable-line no-underscore-dangle

  module.filename = filename; // @ts-ignore

  module._compile(code, filename); // eslint-disable-line no-underscore-dangle


  return module.exports;
}
/**
 * @param {string} a
 * @param {string} b
 * @returns {0 | 1 | -1}
 */


function compareIds(a, b) {
  if (typeof a !== typeof b) {
    return typeof a < typeof b ? -1 : 1;
  }

  if (a < b) {
    return -1;
  }

  if (a > b) {
    return 1;
  }

  return 0;
}
/**
 * @param {Module} a
 * @param {Module} b
 * @returns {0 | 1 | -1}
 */


function compareModulesByIdentifier(a, b) {
  return compareIds(a.identifier(), b.identifier());
}

const MODULE_TYPE = "css/mini-extract";
const AUTO_PUBLIC_PATH = "__mini_css_extract_plugin_public_path_auto__";
const ABSOLUTE_PUBLIC_PATH = "webpack:///mini-css-extract-plugin/";
const BASE_URI = "webpack://";
const SINGLE_DOT_PATH_SEGMENT = "__mini_css_extract_plugin_single_dot_path_segment__";
/**
 * @param {string} str
 * @returns {boolean}
 */

function isAbsolutePath(str) {
  return path.posix.isAbsolute(str) || path.win32.isAbsolute(str);
}

const RELATIVE_PATH_REGEXP = /^\.\.?[/\\]/;
/**
 * @param {string} str
 * @returns {boolean}
 */

function isRelativePath(str) {
  return RELATIVE_PATH_REGEXP.test(str);
} // TODO simplify for the next major release

/**
 * @param {LoaderContext} loaderContext
 * @param {string} request
 * @returns {string}
 */


function stringifyRequest(loaderContext, request) {
  if (typeof loaderContext.utils !== "undefined" && typeof loaderContext.utils.contextify === "function") {
    return JSON.stringify(loaderContext.utils.contextify(loaderContext.context || loaderContext.rootContext, request));
  }

  const 